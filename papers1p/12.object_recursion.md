# Resumen: El Patrón Object Recursion

## Propósito (Intent)
Distribuir el procesamiento de una solicitud a través de una estructura delegando polimórficamente. Object Recursion permite que una solicitud se divida repetidamente en partes más pequeñas que son más fáciles de manejar.

## También Conocido Como
- Recursive Delegation (Delegación Recursiva)

## Motivación
El problema surge al comparar objetos complejos. En lugar de usar un objeto `Comparator` centralizado que conozca la estructura interna de todos los objetos, se delega la responsabilidad a los propios objetos mediante polimorfismo.

**Ejemplo**: Comparar dos motores (`Engine`)
- El cliente envía `=` al primer motor con el segundo como argumento
- El motor compara sus partes (`size` y `power`)
- Si las partes son objetos complejos, continúan el proceso recursivamente
- Las partes simples (como `Integer`) terminan la recursión

## Participantes Clave

### 1. Initiator (Cliente)
- Inicia la solicitud
- No es subtipo de Handler
- Mensaje separado: `makeRequest()`

### 2. Handler (Comparable)
- Define el tipo que puede manejar las solicitudes

### 3. Recurser (Motor)
- Define el enlace al sucesor
- Maneja la solicitud delegando a sus sucesores
- Puede realizar comportamiento extra antes/después de delegar

### 4. Terminator (Integer)
- Termina la recursión implementando completamente la solicitud
- No delega a otros sucesores

## Estructura

```
Initiator → Handler → [Recurser → Terminator]
```

**Flujo típico**:
1. Initiator envía `makeRequest()`
2. Handler (si es Recurser):
   - Ejecuta `preHandleRequest()`
   - Delega a sucesor con `handleRequest()`
   - Ejecuta `postHandleRequest()`
3. Handler (si es Terminator): implementa la solicitud completamente

## Consecuencias

### Ventajas
- **Procesamiento distribuido**: La carga se distribuye através de la estructura
- **Flexibilidad de responsabilidad**: El iniciador no necesita conocer la estructura interna
- **Flexibilidad de roles**: Un handler puede ser Recurser para una solicitud y Terminator para otra
- **Encapsulación mejorada**: Las decisiones de implementación se mantienen dentro de cada objeto

### Desventajas
- **Complejidad de programación**: La recursión es conceptualmente difícil
- Puede hacer el sistema más difícil de entender y mantener si se usa en exceso

## Implementación

### Consideraciones Clave
1. **Tipo de Initiator separado**: `makeRequest()` no debe ser polimórfico con `handleRequest()`
2. **Definición del sucesor**: Los Terminators pueden ignorar el enlace al sucesor

### Ejemplo de Código: Comparación Recursiva

```java
// Objeto terminal (sin recursión)
public class String {
    public boolean equals(String anotherString) {
        // Comparación carácter por carácter
    }
}

// Primer nivel de recursión
public class PersonName {
    private String firstName, lastName;
    
    public boolean equals(PersonName anotherName) {
        return firstName.equals(anotherName.firstName) 
            && lastName.equals(anotherName.lastName);
    }
}

// Segundo nivel de recursión
public class DirectoryEntry {
    private PersonName name;
    
    public boolean equals(DirectoryEntry anotherEntry) {
        return name.equals(anotherEntry.name);
    }
}
```

## Usos Conocidos

1. **Comparación de igualdad** (`equals()`)
2. **Copia/clonación** (`copy()`, `clone()`)
3. **Serialización** (texto o binario)
4. **Conversión a string** (`toString()`, `printString`)
5. **Estructuras de árbol** (mensajes de hoja a raíz o broadcast)

## Patrones Relacionados

### vs. Composite y Decorator
- Composite/Decorator son patrones estructurales
- Object Recursion es behavioral
- Composite/Decorator pueden contener Object Recursion

### vs. Chain of Responsibility
- Chain of Responsibility **contiene** Object Recursion
- Usa una lista enlazada o árbol organizado por especialización/prioridad

### vs. Interpreter
- El mensaje `interpret()` recorre el árbol de sintaxis abstracta usando Object Recursion

### vs. Iterator
- Iteradores internos en estructuras enlazadas usan Object Recursion
- Iteradores externos usan bucles `while`

## Conclusión
Object Recursion es un patrón fundamental que permite distribuir responsabilidades a través de estructuras de objetos mediante delegación polimórfica recursiva. Es particularmente útil para operaciones que necesitan atravesar estructuras complejas manteniendo un buen encapsulamiento y flexibilidad.