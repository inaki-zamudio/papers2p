# Resumen del Patrón Null Object

## Intención
Proporcionar un sustituto para otro objeto que comparte la misma interfaz pero no hace nada. El Null Object encapsula las decisiones de implementación sobre cómo "no hacer nada" y oculta esos detalles a sus colaboradores.

## También Conocido Como
- Stub
- Active Nothing (Nada Activa)

## Motivación
Cuando una clase requiere un colaborador pero no necesita que este realice ninguna acción, el patrón Null Object permite tratar uniformemente a colaboradores que proporcionan comportamiento real y aquellos que no hacen nada.

**Ejemplo**: En el paradigma Modelo-Vista-Controlador de Smalltalk-80, una vista de solo lectura no necesita un controlador, pero la jerarquía de vistas está diseñada para usar uno constantemente.

## Aplicabilidad
Use el patrón Null Object cuando:
- Un objeto requiere un colaborador
- Algunas instancias del colaborador deberían no hacer nada
- Los clientes deben poder ignorar la diferencia entre colaboradores reales y aquellos que no hacen nada
- Se quiere reutilizar el comportamiento de "no hacer nada"
- El comportamiento que podría necesitar ser "no hacer nada" está encapsulado en la clase colaboradora

## Estructura
```
Client ---> AbstractObject
            request()
              |
        +-----+-----+
        |           |
   RealObject   NullObject
   request()    request()
                (do nothing)
```

## Participantes
- **Client (Cliente)**: Requiere un colaborador
- **AbstractObject (Objeto Abstracto)**: Define la interfaz para los colaboradores
- **RealObject (Objeto Real)**: Proporciona comportamiento útil que el cliente espera
- **NullObject (Objeto Nulo)**: Implementa la misma interfaz pero no hace nada

## Consecuencias
### Ventajas
- **Código de cliente simple**: Los clientes tratan uniformemente a colaboradores reales y nulos
- **Encapsulación**: El código de "no hacer nada" está encapsulado en el objeto nulo
- **Reutilización**: Múltiples clientes pueden reutilizar el mismo comportamiento nulo
- **Jerarquías claras**: Define jerarquías consistentes de objetos reales y nulos

### Desventajas
- **Explosión de clases**: Puede requerir una nueva clase NullObject para cada AbstractObject
- **Comportamiento nulo inflexible**: Siempre actúa como objeto nulo, no se transforma en real
- **Dificultad de distribución**: El comportamiento nulo es difícil de distribuir entre varios objetos

## Implementación
### Consideraciones Clave
1. **Null Object como Singleton**: Usualmente se implementa como Singleton ya que no tiene estado
2. **Instancia nula especial**: Alternativa para evitar explosión de clases
3. **Comportamiento nulo personalizado**: Múltiples NullObjects si los clientes esperan diferentes comportamientos nulos
4. **Sin transformación**: Los Null Objects no se transforman en Real Objects
5. **Relación con otros patrones**: Es un caso especial de Strategy, State, Iterator y Adapter

## Ejemplos de Uso Conocidos
- **NoController**: En Smalltalk-80 para vistas de solo lectura
- **NullDragMode**: Para elementos visuales que no pueden ser redimensionados
- **NullInputManager**: Para plataformas sin soporte de internacionalización
- **NullScope**: Como ámbito más externo en la jerarquía de nombres
- **Null_Mutex**: Para servicios que siempre se ejecutan en un solo hilo
- **NullIterator**: Para nodos hoja en estructuras de árbol

## Patrones Relacionados
- **Singleton**: Los Null Objects suelen implementarse como Singletons
- **Strategy**: Null Object como estrategia que no hace nada
- **State**: Null Object como estado que no permite acciones
- **Iterator**: NullIterator como caso especial
- **Adapter**: Null Adapter como adaptador que no envuelve nada

## Referencias Clave
- Gamma, Helm, Johnson, Vlissides - "Design Patterns" (1995)
- Bruce Anderson - "Null Object" (1995)
- James Coplein - Correspondencia por email
- VisualWorks Smalltalk - Múltiples implementaciones

El patrón Null Object es una solución elegante para eliminar comprobaciones de null y código condicional, promoviendo un diseño más limpio y mantenible.