# Resumen: Method Object

## Problema
- Cuando un método se vuelve demasiado complejo, con muchas líneas de código, múltiples parámetros y variables temporales.
- La aplicación de **Composed Method** no es efectiva porque cada parte separada requeriría pasar demasiados parámetros (6-8 en el ejemplo).
- El código se convierte en un "desastre monstruoso" que dificulta la comunicación y mantenimiento.

## Solución: Method Object
Crear un objeto que represente una invocación del método, utilizando variables de instancia para compartir el espacio de nombres.

### Implementación
1. **Crear una clase** con nombre derivado del método original
2. **Agregar variables de instancia** para:
   - El receptor original
   - Todos los argumentos del método
   - Todas las variables temporales
3. **Crear un método constructor** que tome el receptor original y los argumentos
4. **Implementar método `#computar`** copiando el cuerpo del método original
5. **Reemplazar el método original** por uno que cree una instancia de la nueva clase y envíe `#computar`

## Ejemplo del documento
- **Método original**: `Obligacion >> enviarTarea: unaTarea trabajo: unTrabajo` (150 líneas)
- **Clase creada**: `EnviadorDeTareas`
- **Variables de instancia**: `obligacion`, `tarea`, `trabajo`, `sinProcesar`, `procesado`, `copiado`, `ejecutado`
- **Resultado**: El método `#computar` ahora puede ser refactorizado usando Composed Method sin pasar parámetros

## Beneficios
- Permite aplicar **Composed Method** efectivamente
- Reduce la longitud del código (en el ejemplo: a la mitad)
- Mejora la legibilidad ("se leía como documentación")
- Facilita encontrar y corregir bugs
- Aunque son objetos "verbos" sin análogo en el mundo real, su valor justifica su uso

## Conclusión
Method Object es un patrón valioso para manejar métodos extremadamente complejos que no responden bien a otras técnicas de refactorización, representando a menudo el comportamiento central de sistemas complejos.