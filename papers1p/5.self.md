# Resumen: Self: The Power of Simplicity

## Autores
- **David Ungar** – Stanford University
- **Randall B. Smith**

---

## Abstract
Self es un nuevo lenguaje orientado a objetos para programación exploratoria, basado en ideas simples y concretas:
- **Prototipos**
- **Slots (ranuras)**
- **Comportamiento**

Los prototipos combinan herencia e instanciación en un marco más simple y flexible que los lenguajes basados en clases. Los slots unifican variables y procedimientos, permitiendo que la herencia reemplace el alcance léxico. Al no distinguir entre estado y comportamiento, Self elimina las barreras entre objetos, procedimientos y clausuras.

---

## Introducción
Self es un lenguaje orientado a objetos que:
- No tiene clases ni variables.
- Usa **mensajes** como operación fundamental.
- Accede al estado mediante mensajes enviados a `self`.
- Está diseñado para programación exploratoria (tipado dinámico, recolección automática de basura).

Principios de diseño:
- **Mensajes como base**: Todo es un mensaje, incluso el acceso al estado.
- **Navaja de Occam**: Economía conceptual (menos conceptos, más potencia).
- **Concreción**: Uso de prototipos en lugar de clases.

---

## Prototipos: Uniendo Clases e Instancias

### Comparación con Smalltalk
| Aspecto | Smalltalk (con clases) | Self (sin clases) |
|---------|------------------------|-------------------|
| Relación | "es una" (instancia) y "tipo de" (subclase) | "hereda de" (una sola relación) |
| Creación | Instanciación (seguir un plan) | Clonación (copiar un ejemplo) |
| Objetos únicos | Requiere clase con una instancia | Cualquier objeto puede ser único |
| Meta-regresión | Clase → Metaclase → Meta-metaclase… | No aplica |

### Ventajas de los Prototipos
- **Relaciones más simples**: Solo "hereda de".
- **Creación por copia**: Más intuitiva que la instanciación.
- **Objetos únicos**: Fáciles de crear y personalizar.
- **Sin meta-regresión**: Los objetos pueden ser autosuficientes.

---

## Unificación de Estado y Comportamiento
- No hay acceso directo a variables; todo se hace mediante mensajes.
- Ejemplo: `x` lee el valor, `x: 17` lo asigna.
- Permite:
  - Reemplazar variables por cómputos (ej: coordenada `x` aleatoria).
  - Compartir estado entre objetos.
  - Implementar "demonios" o valores activos.

---

## Clausuras y Objetos
- Self unifica objetos, métodos y clausuras mediante slots y herencia.
- Las clausuras son prototipos de registros de activación.
- El enlace de entorno se maneja mediante el enlace padre (`parent`).
- El `self` implícito inicia la búsqueda en el registro de activación actual.

---

## Sintaxis
- Objetos se escriben entre corchetes `[]`.
- Métodos entre llaves `{}`.
- Slots se declaran entre `| ... |`.
- Ejemplos:
  - `[ | x. | ]` → slot `x` y asignación `x:`.
  - `[ | tally ← 0 | ... ]` → slot inicializado.
  - `[ | x = 3 | ]` → slot de solo lectura.

---

## Ejemplo: Estructura de Datos "Set"
Se implementa una tabla hash con direccionamiento abierto. Muestra:
- Creación de un prototipo de conjunto vacío.
- Métodos para `add:`, `includes:`, `clone`.
- Uso de bloques y herencia para compartir comportamiento.

---

## Trabajo en Progreso (1987)
- **Herencia múltiple**: Resolución de conflictos mediante paths de envío a `self`.
- **Encapsulación**: Aún no implementada.
- **Detalles de activación**: Unificación de métodos y bloques.

---

## Conclusiones
- Self es un paradigma más simple y expresivo que los lenguajes basados en clases.
- Elimina clases y variables, unificando objetos, procedimientos y clausuras.
- Ofrece flexibilidad para modelar objetos únicos, valores activos y compartir estado.
- La simplicidad conceptual no limita la expresividad, sino que la potencia.

---

## Referencias Clave
- Goldberg & Robson: *Smalltalk-80*
- Lieberman: *Prototipos y comportamiento compartido*
- Borning: *ThingLab y entornos basados en prototipos*
- Steele: *Lambda, the Ultimate Imperative*

---

**Publicado en**: OOPSLA '87 Proceedings  
**Fecha**: 4-8 de octubre de 1987  
**Páginas**: 227–242